# Copyright (C) 2011, 2012 David Maxwell
# 
# This file is part of PISM.
# 
# PISM is free software; you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# 
# PISM is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
# 
# You should have received a copy of the GNU General Public License
# along with PISM; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

import PISM
from PISM import netCDF

has_siple = False
try:
  import siple
  has_siple = True
except:
  pass

has_tao = False
try:
  PISM.__getattribute__('InvSSATikhonovLCL')
  has_tao = True
except:
  pass

import math
from petsc4py import PETSc

from PISM.logging import logError, logMessage
import numpy as np
import sys

tauc_param_types = {"ident":PISM.InvTaucParamIdent, 
               "square":PISM.InvTaucParamSquare,
               "exp":PISM.InvTaucParamExp,
               "trunc":PISM.InvTaucParamTruncatedIdent }

class TaucParamFactory:
  def create(self, config, name=None ):
    if name is None:
      name = PISM.optionsList(PISM.Context().com,"-inv_ssa_tauc_param","zeta->tauc parameterization",["ident","square","exp","trunc"],"")
      if name == "":
        name = config.get_string("inv_ssa_tauc_param")
    tauc_param = tauc_param_types[name]()
    tauc_param.init(config)
    return tauc_param

tauc_param_factory = TaucParamFactory()

def invSSAFactory(grid,basal,ec,tauc_param,config,name=None):
  InvSSAForwardProblem = PISM.InvSSAForwardProblem
  if PISM.optionsFlag("inv_old_siple",""):
    InvSSAForwardProblem = PISM.InvSSAForwardProblem_dep
  return InvSSAForwardProblem(grid,basal,ec,tauc_param,config)

def constructTikhonovFunctionals(ssarun):
  vecs = ssarun.modeldata.vecs

  misfit_weight = None
  if vecs.has('vel_misfit_weight'):
    misfit_weight = vecs.vel_misfit_weight

  tauc_fixed_mask = None
  if vecs.has('zeta_fixed_mask'):
    tauc_fixed_mask = vecs.zeta_fixed_mask

  grid = ssarun.grid

  tauc_norm = grid.config.get_string("inv_ssa_tauc_norm")
  if tauc_norm == "hilbert":
    cL2 = grid.config.get("inv_ssa_cL2");
    cH1 = grid.config.get("inv_ssa_cH1");

    area = 4*grid.Lx*grid.Ly;
    length_scale = grid.config.get("inv_ssa_length_scale");
    cL2 /= area;
    cH1 /= area;
    cH1 *= (length_scale*length_scale);

    designFunctional = PISM.H1NormFunctional2S(grid,cL2,cH1,tauc_fixed_mask)

  elif tauc_norm == "tv":
    area = 4*grid.Lx*grid.Ly;
    length_scale = grid.config.get("inv_ssa_length_scale");
    lebesgue_exponent = grid.config.get("inv_ssa_tv_exponent");
    cTV = 1/area
    cTV *= (length_scale)**(lebesgue_exponent)
    designFunctional = PISM.TotalVariationFunctional2S(grid,cTV,lebesgue_exponent,tauc_fixed_mask)
  else:
    raise Exception("Unknown inv_ssa_tauc_norm '%s'; unable to construct solver.",tauc_norm)

  velocity_scale = grid.config.get("inv_ssa_velocity_scale")/PISM.secpera;

  stateFunctional = PISM.MeanSquareFunctional2V(grid,misfit_weight);    
  stateFunctional.normalize(velocity_scale);

  return (designFunctional,stateFunctional)


class InvSSARun(PISM.ssa.SSARun):

  def setup(self):

    PISM.ssa.SSARun.setup(self)

    vecs = self.modeldata.vecs

    # The SSA instance will not keep a reference to pismVars; it only uses it to extract
    # its desired variables.  So it is safe to pass it pismVars and then let pismVars
    # go out of scope at the end of this method.

    self.ssa.init(vecs.asPISMVars())

    if vecs.has('vel_bc'):
      self.ssa.set_boundary_conditions(vecs.bc_mask,vecs.vel_bc)

    # Cache the values of the coefficients at quadrature points once here.
    # Subsequent solves will then not need to cache these values.
    self.ssa.cacheQuadPtValues();

  def _constructSSA(self):
    md = self.modeldata
    self.tauc_param = tauc_param_factory.create(self.config)
    return invSSAFactory(md.grid,md.basal,md.enthalpyconverter,self.tauc_param,self.config)

class InvSSAFromInputFile(PISM.ssa.SSAFromInputFile):
  def __init__(self,input_filename,inv_data_filename):
    PISM.ssa.SSAFromInputFile.__init__(self,input_filename)
    self.inv_data_filename = inv_data_filename

  def _setFromOptions(self):
    PISM.ssa.SSAFromInputFile._setFromOptions(self)
    for o in PISM.OptionsGroup(PISM.Context().com,"","Vel2Tauc"):
      self.using_zeta_fixed_mask = PISM.optionsFlag("-use_zeta_fixed_mask","Keep tauc constant except where grounded ice is present",default=True)

  def _initGrid(self):
    # The implementation in PISM.ssa.SSAFromInputFile uses a non-periodic
    # grid only if the run is regional and "ssa_method=fem" in the config
    # file.  For inversions, we always use an FEM type method, so for
    # regional inversions, we always use a non-periodic grid.
    periodicity = PISM.XY_PERIODIC
    (pstring,pflag) = PISM.optionsListWasSet(self.grid.com,'-periodicity',"Grid periodicity",['x','y','xy', 'none'],'xy')
    if pflag:
      pdict = {'x':PISM.X_PERIODIC,   'y':PISM.Y_PERIODIC, 
               'xy':PISM.XY_PERIODIC, 'none':PISM.NOT_PERIODIC }
      periodicity = pdict[pstring]
    else:
      periodicity = PISM.XY_PERIODIC
      if self.is_regional:
        periodicity=PISM.NOT_PERIODIC
    PISM.util.init_grid_from_file(self.grid,self.boot_file,periodicity);

  def setup(self):

    PISM.ssa.SSAFromInputFile.setup(self)

    vecs = self.modeldata.vecs

    if vecs.has('vel_bc'):
      self.ssa.set_boundary_conditions(vecs.bc_mask,vecs.vel_bc)

    if vecs.has('zeta_fixed_mask') and self.using_zeta_fixed_mask:
      self.ssa.set_tauc_fixed_locations(vecs.zeta_fixed_mask)

    self.ssa.init(vecs.asPISMVars())

    # Cache the values of the coefficeints at quadrature points once here.
    # Subsequent solves will then not need to cache these values.
    self.ssa.cacheQuadPtValues();


  def _initSSACoefficients(self):
    self._allocStdSSACoefficients()

    # Read PISM SSA related state variables

    vecs = self.modeldata.vecs
    thickness = vecs.thickness; bed = vecs.bed; enthalpy = vecs.enthalpy
    mask = vecs.ice_mask; surface = vecs.surface

    # Read in the PISM state variables that are used directly in the SSA solver
    for v in [thickness, bed, enthalpy]:
      v.regrid(self.boot_file,True)

    # variables mask and surface are computed from the geometry previously read
    sea_level = 0 # FIXME setFromOption?
    gc = PISM.GeometryCalculator(sea_level, self.config)
    gc.compute(bed,thickness,mask,surface)

    if PISM.util.fileHasVariable(self.boot_file,'ssa_driving_stress_x'):
      vecs.add( PISM.util.standardDrivingStressX(self.grid))
      vecs.ssa_driving_stress_x.regrid(self.boot_file,critical=True)

    if PISM.util.fileHasVariable(self.boot_file,'ssa_driving_stress_y'):
      vecs.add( PISM.util.standardDrivingStressY(self.grid))
      vecs.ssa_driving_stress_y.regrid(self.boot_file,critical=True)

    if self.is_regional:
      vecs.add( PISM.util.standardNoModelMask(self.grid), 'no_model_mask' )
      vecs.no_model_mask.regrid(self.boot_file,True)
      vecs.add( vecs.surface, 'usurfstore')
      vecs.setPISMVarsName('usurfstore','usurfstore')

    if self.config.get_flag('ssa_dirichlet_bc'):
      vecs.add( PISM.util.standard2dVelocityVec( self.grid, name='_ssa_bc', desc='SSA velocity boundary condition',intent='intent' ), "vel_ssa_bc" )
      has_u_ssa_bc = PISM.util.fileHasVariable(self.boot_file,'u_ssa_bc');
      has_v_ssa_bc = PISM.util.fileHasVariable(self.boot_file,'v_ssa_bc');
      if (not has_u_ssa_bc) or (not has_v_ssa_bc):
        PISM.verbPrintf(2,self.grid.com, "Input file '%s' missing Dirichlet boundary data u/v_ssa_bc; using zero default instead." % self.boot_file)
        vecs.vel_ssa_bc.set(0.)
      else:
        vecs.vel_ssa_bc.regrid(self.boot_file,True)

      if self.is_regional:
        vecs.add( vecs.no_model_mask, 'bc_mask')
      else:
        vecs.add( PISM.util.standardBCMask( self.grid ), 'bc_mask' )
        bc_mask_name = vecs.bc_mask.string_attr("name")
        if PISM.util.fileHasVariable(self.boot_file,bc_mask_name):
          vecs.bc_mask.regrid(self.boot_file,True)          
        else:
          PISM.verbPrintf(2,self.grid.com,"Input file '%s' missing Dirichlet location mask '%s'.  Default to no Dirichlet locations." %(self.boot_file,bc_mask_name))
          vecs.bc_mask.set(0)
      # We call this variable 'bc_mask' in the python code, it is called
      # 'bcflag' when passed between pism components, and it has yet
      # another name when written out to a file.  Anyway, we flag its
      # export to PISMVars name here.
      vecs.setPISMVarsName('bc_mask','bcflag')

    vecs.add( PISM.util.standardVelocityMisfitWeight(self.grid) )
    weight = vecs.vel_misfit_weight
    weight.regrid(self.inv_data_filename,True)

    zeta_fixed_mask = PISM.IceModelVec2Int()
    zeta_fixed_mask.create(self.grid, 'zeta_fixed_mask', True, self.grid.max_stencil_width);
    zeta_fixed_mask.set_attrs("model_state", "tauc_unchanging integer mask", "", "");
    mask_values=[0,1]
    zeta_fixed_mask.set_attr("flag_values", mask_values);
    zeta_fixed_mask.set_attr("flag_meanings","tauc_changable tauc_unchangeable");
    zeta_fixed_mask.output_data_type = PISM.PISM_BYTE;

    zeta_fixed_mask.set(1);
    with PISM.util.Access(comm=zeta_fixed_mask,nocomm=mask):
      mq = PISM.MaskQuery(mask)
      for (i,j) in self.grid.points():
        if mq.grounded_ice(i,j):
          zeta_fixed_mask[i,j] = 0;
    vecs.add(zeta_fixed_mask)

  def _constructSSA(self):
    md = self.modeldata
    self.tauc_param = PISM.invert_ssa.tauc_param_factory.create(self.config)
    return PISM.invert_ssa.invSSAFactory(md.grid,md.basal,md.enthalpyconverter,self.tauc_param,self.config)


def InvSSASolver(ssarun,method=None):
  """Returns an inverse solver appropriate for the config variable 'inv_ssa_method'.
  The problem :ssarun: should be a subclass of :InvSSARun:.""" 
  if method is None:
    method = ssarun.config.get_string('inv_ssa_method')
  if method == 'tikhonov_gn':
    import invert_ssa_gn
    return invert_ssa_gn.InvSSASolver_Tikhonov(ssarun,method)    
  elif method.startswith('tikhonov'):
    if not has_tao:
      raise RuntimeError("Inversion method '%s' requires the TAO library.\nInstall from http://www.mcs.anl.gov/tao and rebuild PISM with TAO support." % method)
    import invert_ssa_tao
    return invert_ssa_tao.InvSSASolver_Tikhonov(ssarun,method)
  if method == 'sd' or method == 'nlcg' or method == 'ign':
    if not has_siple:
      raise RuntimeError("Inversion method '%s' requires the siple python library.\nInstall from https://github.com/damaxwell/siple" % method)
    import invert_ssa_siple
    return invert_ssa_siple.InvSSASolver_Siple(ssarun,method)
  raise Exception("Unknown inverse method '%s'; unable to construct solver.",method)

class PrintTikhonovProgress:
  def __init__(self):
    self.misfit_history = []

  def __call__(self,invssasolver,it,data):
    eta = data.eta
    stateVal = data.stateVal
    designVal = data.designVal
    velScale = invssasolver.ssarun.config.get("inv_ssa_velocity_scale");

    sWeight = 1
    dWeight = 1./eta

    logMessage("----------------------------------------------------------\n");
    logMessage("Iteration %d\n" % it)    
    misfit = math.sqrt(stateVal)*velScale
    logMessage("RMS misfit: %.8g\n" % misfit)
    self.misfit_history.append(misfit)
    logMessage("sqrt(design objective) %.8g; weighted %.8g\n" % (math.sqrt(designVal),math.sqrt(designVal*dWeight))) 
    if data.has_key('grad'):
      logMessage("gradient: design %.8g state %.8g sum %.8g\n" % (data.grad_zeta.norm(PETSc.NormType.NORM_2)*dWeight,data.grad_u.norm(PETSc.NormType.NORM_2)*sWeight,data.grad.norm(PETSc.NormType.NORM_2)))
    else:
      logMessage("gradient: design %.8g state %.8g; constraints: %.8g\n" % (data.grad_zeta.norm(PETSc.NormType.NORM_2)*dWeight,data.grad_u.norm(PETSc.NormType.NORM_2)*sWeight,data.constraints.norm(PETSc.NormType.NORM_2)))
    logMessage("tikhonov functional: %.8g\n" % (stateVal*sWeight + designVal*dWeight) )

  def write(self,output_filename):
    if PISM.Context().rank == 0:
      nc = netCDF.Dataset(output_filename, 'a')  # append
      nc.createDimension('inv_ssa_iter',len(self.misfit_history))
      nc_misfit = nc.createVariable('inv_ssa_misfit','f8',dimensions=('inv_ssa_iter'))
      nc_misfit.setncattr('_units','m/a')
      nc_misfit[:] = self.misfit_history[:]
      nc.close()

class MonitorAdjoint:
  def __init__(self):
    self.Td = None
    self.TStarR = None
    self.didWarning = False

  def __call__(self,inverse_solver,count,data):
    import PISM.sipletools
    method = inverse_solver.method
    if method != 'sd' and method !='nlcg' and method != 'ign':
      if not self.didWarning:
        PISM.verbPrintf(1,PISM.Context().com,'\nWarning: unable to monitor adjoint for inverse method: %s\nOption -inv_monitor_adjoint ignored\n' % method)
      self.didWarning = True
      return
    fp = inverse_solver.forward_problem
    d = PISM.sipletools.PISMLocalVector(data.d)
    r = PISM.sipletools.PISMLocalVector(data.r)
    self.Td=fp.T(d,self.Td)
    self.TStarR=forward_problem.TStar(r,out=self.TStarR)
    ip1 = fp.domainIP(d,self.TStarR)
    ip2 = fp.rangeIP(self.Td,r)
    logMessage("adjoint test: <Td,r>=%g <d,T^*r>=%g (percent error %g)",ip1,ip2,(abs(ip1-ip2))/max(abs(ip1),abs(ip2)))


class MonitorAdjointLin:
  def __init__(self):
    self.Td = None
    self.TStarR = None

  def __call__(self,inverse_solver,count,data):
    import PISM.sipletools
    fp = inverse_solver.forward_problem
    r = PISM.sipletools.PISMLocalVector(data.r)
    d = PISM.sipletools.PISMLocalVector(data.d)
    self.Td=fp.T(d,self.Td)
    self.TStarR=forward_problem.TStar(r,out=self.TStarR)
    ip1 = fp.domainIP(d,self.TStarR)
    ip2 = fp.rangeIP(self.Td,r)
    logMessage("adjoint test: <Td,r>=%g <d,T^*r>=%g (percent error %g)",ip1,ip2,(abs(ip1-ip2))/max(abs(ip1),abs(ip2)))

class PrintRMSMisfit:
  def __init__(self):
    self.misfit_history = []
  def __call__(self,invssa_solver,it,data):
    if invssa_solver.method.startswith('tikhonov'):
      raise NotImplementedError()
    else:
      import PISM.sipletools
      fp = invssa_solver.forward_problem
      r=PISM.sipletools.PISMLocalVector(data.r)
      rms_misfit = math.sqrt(fp.rangeIP(r,r))
    logMessage("Iteration [%d]: RMS misfit %.8g\n" % (it,rms_misfit));
    self.misfit_history.append(rms_misfit)
  def write(self,output_filename):
    if PISM.Context().rank == 0:
      nc = netCDF.Dataset(output_filename, 'a')  # append
      nc.createDimension('inv_ssa_iter',len(self.misfit_history))
      nc_misfit = nc.createVariable('inv_ssa_misfit','f8',dimensions=('inv_ssa_iter'))
      nc_misfit.setncattr('_units','m/a')
      nc_misfit[:] = self.misfit_history[:]
      nc.close()

class ZetaSaver:
  """Iteration listener used to save a copy of the current value
  of zeta (i.e. parameterized tauc) at each iteration during an inversion."""
  def __init__(self,output_filename):
    self.output_filename = output_filename

  def __call__(self,inverse_solver,count,data):
    zeta = data.zeta
    # The solver doesn't care what the name of zeta is, and we
    # want it called 'zeta_inv' in the output file, so we rename it.
    zeta.rename('zeta_inv', 'last iteration of parameterized basal yeild stress computed by inversion','')
    zeta.write(self.output_filename)


def pauseListener(*args):
  PISM.logging.pause()

class PlotListener:
  def __init__(self,grid):
    self.grid = grid
    self.tz_scalar = PISM.toproczero.ToProcZero(grid,dof=1)
    self.tz_vector = PISM.toproczero.ToProcZero(grid,dof=2)
    self.figs = {}

  def toproczero(self,*args):
    if len(args) == 2:
      data = args[0]
      name = args[1]
      v = data[name]
    else:
      v = args[0]
    if v is None:
      return None
    if v.get_dof()==1:
      return self.tz_scalar.communicate(v)
    return self.tz_vector.communicate(v)

  def figure(self,name='default'):
    fig = self.figs.get(name)
    if fig is None:
      import matplotlib.pyplot as pp
      fig = pp.figure()
      self.figs[name]=fig
    return fig.number

  def iteration(self,solver,itr,data):
    raise NotImplementedError()



