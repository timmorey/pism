# Copyright (C) 2011, 2012, 2013 David Maxwell
# 
# This file is part of PISM.
# 
# PISM is free software; you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# 
# PISM is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
# 
# You should have received a copy of the GNU General Public License
# along with PISM; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

import PISM
from PISM import IceModelVec2S, IceModelVec2V, netCDF
import sys, time
import numpy as np

class Access:
  def __init__(self,nocomm=None,comm=None):
    if not nocomm is None:
      if isinstance(nocomm,list) or isinstance(nocomm,tuple):
        self.nocomm = nocomm
      else:
        self.nocomm = [nocomm]
      for v in self.nocomm:
        v.begin_access()
    else:
      self.nocomm = None

    if not comm is None:
      if isinstance(comm,list) or isinstance(comm,tuple):
        self.comm = comm
      else:
        self.comm = [comm]
      for v in self.comm:
        v.begin_access()
    else:
      self.comm = None
  def __enter__(self):
    pass
  def __exit__(self,exc_type, exc_value, traceback):
    if not self.nocomm is None:
      for v in self.nocomm:
        v.end_access()
      self.nocomm = None
    
    if not self.comm is None:
      for v in self.comm:
        v.end_access()
        v.update_ghosts()
      self.comm = None

WIDE_STENCIL=2

def writeProvenance(outfile,message=None):
  """Saves the time and command line arguments (or the provided message) to 
  the history attribute of the NC file 'outfile'"""
  rank = PISM.Context().rank
  if rank == 0:
    nc = netCDF.Dataset(outfile, 'a')  # append
    if message is None:
      message = time.asctime() + ': ' + ' '.join(sys.argv)
    if 'history' in nc.ncattrs():
      nc.history = message + '\n' + nc.history
    else:
      nc.history = message
    nc.source = "PISM " + PISM.PISM_Revision
    nc.close()
  PISM.Context().com.barrier()

def standardIceSurfaceVec(grid,name='usurf'):
  surface = IceModelVec2S();
  surface.create(grid, name, True, grid.max_stencil_width)
  surface.set_attrs("diagnostic", "ice upper surface elevation", "m", "surface_altitude");
  return surface;

def standardIceThicknessVec(grid,name='thk'):
  thickness = IceModelVec2S();
  thickness.create(grid, name, True, grid.max_stencil_width);
  thickness.set_attrs("model_state", "land ice thickness", "m", "land_ice_thickness");
  thickness.set_attr("valid_min", 0.0);
  return thickness

def standardIceSurfaceStoreVec(grid,name='usurfstore'):
  usurfstore = IceModelVec2S()
  usurfstore.create(grid, name, True, 2)
  usurfstore.set_attrs("model_state", 
    "saved surface elevation for use to keep surface gradient constant in no_model strip",
    "m", "");
  return usurfstore

def standardIceThicknessStoreVec(grid,name='thkstore'):
  thkstore = IceModelVec2S();
  thkstore.create(grid, name, True, 1)
  thkstore.set_attrs("model_state", 
    "saved ice thickness for use to keep driving stress constant in no_model strip",
    "m", "")
  return thkstore

def standardBedrockElevationVec(grid,name='topg',desc="bedrock surface elevation"):
  bed = IceModelVec2S()
  bed.create(grid, name, True, grid.max_stencil_width);
  bed.set_attrs("model_state", desc, "m", "bedrock_altitude");
  return bed

def standardYieldStressVec(grid,name='tauc',desc="yield stress for basal till (plastic or pseudo-plastic model)"):
  # yield stress for basal till (plastic or pseudo-plastic model)
  tauc = IceModelVec2S()
  tauc.create(grid, name, True, grid.max_stencil_width);
  tauc.set_attrs("diagnostic", desc, "Pa", ""); 
  return tauc;

def standardEnthalpyVec(grid,name='enthalpy'):
  enthalpy = PISM.IceModelVec3()
  enthalpy.create(grid, name, True, grid.max_stencil_width);
  enthalpy.set_attrs("model_state", "ice enthalpy (includes sensible heat, latent heat, pressure)", "J kg-1", "");
  return enthalpy;

def standardBasalMeltRateVec(grid,name='bmelt'):
  bmr = IceModelVec2S()
  bmr.create(grid, "bmelt", True, grid.max_stencil_width);
  bmr.set_attrs("model_state",
                 "ice basal melt rate in ice thickness per time",
                 "m s-1", "land_ice_basal_melt_rate")
  bmr.set_glaciological_units("m year-1")
  bmr.write_in_glaciological_units = True;
  bmr.set_attr("comment", "positive basal melt rate corresponds to ice loss");
  return bmr
  
def standardTillPhiVec(grid,name='tillphi',desc="friction angle for till under grounded ice sheet"):
  tillphi = IceModelVec2S()
  tillphi.create(grid,name,True,grid.max_stencil_width)
  # // ghosted to allow the "redundant" computation of tauc
  # // PROPOSED standard_name = land_ice_basal_material_friction_angle
  tillphi.set_attrs("climate_steady", desc,
                    "degrees", "")
  tillphi.time_independent = True
  return tillphi

def standardBasalWaterVec(grid,name='bwat',desc="effective thickness of subglacial melt water"):
  bwat = IceModelVec2S()
  bwat.create(grid,name,True,grid.max_stencil_width)
  bwat.set_attrs("model_state", desc,
                 "m", "")
  #// NB! Effective thickness of subglacial melt water *does* vary from 0 to hmelt_max meters only.
  bwat.set_attr("valid_min", 0.0)
  valid_max = PISM.global_config().get("bwat_max")
  bwat.set_attr("valid_max", valid_max )
  return bwat

def standard2dVelocityVec(grid,name="",desc="",intent="",stencil_width=WIDE_STENCIL):
  if name is None: name="" # FIXME
  vel = IceModelVec2V();
  if stencil_width == 0:
    vel.create(grid,name,False)
  else:
    vel.create(grid,name,True,stencil_width)    
  vel.set_attrs(intent, "%s%s" %("X-component of the ",desc), "m s-1", "", 0);
  vel.set_attrs(intent, "%s%s" %("Y-component of the ",desc), "m s-1", "", 1);
  vel.set_glaciological_units("m year-1");
  vel.write_in_glaciological_units = True
  huge_vel = 1e10/PISM.secpera;
  attrs = [ ("valid_min", -huge_vel), ("valid_max", huge_vel), ("_FillValue", 2*huge_vel) ]
  for a in attrs: 
    for component in range(2):
      vel.set_attr(a[0],a[1],component)
  vel.set(2*huge_vel)
  return vel

def standardDrivingStressX(grid,name="ssa_driving_stress_x",desc="driving stress",intent="model_state"):
  stress = IceModelVec2S();
  stress.create(grid,name,True,grid.max_stencil_width)
  stress.set_attrs(intent, "%s%s" %("X-component of the ",desc), "Pa", "");
  return stress

def standardDrivingStressY(grid,name="ssa_driving_stress_y",desc="driving stress",intent="model_state"):
  stress = IceModelVec2S();
  stress.create(grid,name,True,grid.max_stencil_width)
  stress.set_attrs(intent, "%s%s" %("X-component of the ",desc), "Pa", "");
  return stress

def standardVelocityMisfitWeight(grid,name="vel_misfit_weight"):
  vel_misfit_weight = PISM.IceModelVec2S();
  vel_misfit_weight.create(grid, name, True, PISM.util.WIDE_STENCIL)
  vel_misfit_weight.set_attrs("diagnostic", "weight for surface velocity misfit functional", "", "");
  return vel_misfit_weight

def standardCBar(grid,name="cbar"):
  cbar = IceModelVec2S()
  cbar.create(grid, name, False);
  cbar.set_attrs("diagnostic",
                 "magnitude of vertically-integrated horizontal velocity of ice",
                 "m s-1", "")
  cbar.set_glaciological_units("m year-1")
  cbar.set_attr("valid_min", 0.0);
  cbar.write_in_glaciological_units = True
  return cbar


def standardVelSurfaceMask(grid,name="vel_surface_mask"):
  vel_surface_mask = PISM.IceModelVec2Int()
  vel_surface_mask.create(grid, name, False);
  vel_surface_mask.set_attrs("diagnostic", "velocity observations mask", "", "");
  mask_values=[0,1]
  vel_surface_mask.set_attr("flag_values", mask_values);
  vel_surface_mask.set_attr("flag_meanings","no_observed observed");
  vel_surface_mask.output_data_type = PISM.PISM_BYTE;
  return vel_surface_mask

def standardIceMask(grid,name='mask'):
  ice_mask = PISM.IceModelVec2Int()
  ice_mask.create(grid, name, True, grid.max_stencil_width);
  ice_mask.set_attrs("model_state", "grounded_dragging_floating integer mask", "", "");
  mask_values=[PISM.MASK_ICE_FREE_BEDROCK, PISM.MASK_GROUNDED, PISM.MASK_FLOATING,
               PISM.MASK_ICE_FREE_OCEAN]
  ice_mask.set_attr("flag_values", mask_values);
  ice_mask.set_attr("flag_meanings","ice_free_bedrock dragging_sheet floating ice_free_ocean");
  ice_mask.output_data_type = PISM.PISM_BYTE;
  return ice_mask

def standardBCMask(grid,name='bc_mask'):
  bc_mask = PISM.IceModelVec2Int()
  bc_mask.create(grid, name, True, grid.max_stencil_width);
  bc_mask.set_attrs("model_state", "grounded_dragging_floating integer mask", "", "");
  mask_values=[0,1]
  bc_mask.set_attr("flag_values", mask_values);
  bc_mask.set_attr("flag_meanings","no_data ssa_dirichlet_bc_location");
  bc_mask.output_data_type = PISM.PISM_BYTE;
  return bc_mask


def standardNoModelMask(grid,name='no_model_mask'):
  no_model_mask = PISM.IceModelVec2Int()
  no_model_mask.create(grid, name, True, grid.max_stencil_width);
  no_model_mask.set_attrs("model_state",
    "mask: zeros (modeling domain) and ones (no-model buffer near grid edges)",
    "", ""); 

  mask_values=[0,1];
  no_model_mask.set_attr("flag_values", mask_values)
  no_model_mask.set_attr("flag_meanings", "normal special_treatment")
  no_model_mask.output_data_type = PISM.PISM_BYTE;
  no_model_mask.time_independent = True
  no_model_mask.set(0)
  return no_model_mask

def standardMisfitElementMask(grid,name='misfit_element_mask'):
  misfit_element_mask = PISM.IceModelVec2Int()
  misfit_element_mask.create(grid, name, True, grid.max_stencil_width);
  misfit_element_mask.set_attrs("model_state",
    "mask: 0=exclude 1=include correspoinding grid element in inversion misfit domain",
    "", ""); 

  mask_values=[0,1];
  misfit_element_mask.set_attr("flag_values", mask_values)
  misfit_element_mask.set_attr("flag_meanings", "normal special_treatment")
  misfit_element_mask.output_data_type = PISM.PISM_BYTE;
  misfit_element_mask.time_independent = True
  misfit_element_mask.set(0)
  return misfit_element_mask



def standardLongitudeVec(grid,name="lon"):
  longitude = PISM.IceModelVec2S()
  longitude.create(grid, name, True)
  longitude.set_attrs("mapping", "longitude", "degree_east", "longitude")
  longitude.time_independent = True
  longitude.set_attr("coordinates", "")
  longitude.set_attr("grid_mapping", "")
  return longitude

def standardLatitudeVec(grid,name="lat"):
  latitude = PISM.IceModelVec2S()
  latitude.create(grid, name, True)
  latitude.set_attrs("mapping", "latitude", "degree_east", "latitude")
  latitude.time_independent = True
  latitude.set_attr("coordinates", "")
  latitude.set_attr("grid_mapping", "")
  return latitude

def fileHasVariable(filename,varname):
  ds = netCDF.Dataset(filename)
  has_var = ds.variables.has_key(varname)
  ds.close()
  return has_var
  

def init_shallow_grid(grid,Lx,Ly,Mx,My,p):
  grid.Lx = Lx;
  grid.Ly = Ly;
  grid.periodicity = p;
  grid.Mx = Mx; grid.My=My; grid.Mz=3;

  grid.compute_nprocs();
  grid.compute_ownership_ranges();
  grid.compute_vertical_levels()
  grid.compute_horizontal_spacing();
  grid.allocate()

def init_grid(grid,Lx,Ly,Lz,Mx,My,Mz,p):
  grid.Lx = Lx;
  grid.Ly = Ly;
  grid.Lz = Lz;
  grid.periodicity = p;
  grid.Mx = Mx; grid.My=My; grid.Mz = Mz;

  grid.compute_nprocs();
  grid.compute_ownership_ranges();
  grid.compute_vertical_levels()
  grid.compute_horizontal_spacing();
  grid.allocate()

def init_grid_from_file(grid,bootfile,periodicity=PISM.NOT_PERIODIC,variable='enthalpy'):
  pio = PISM.PIO(grid.com, grid.rank, "netcdf3")

  pio.open(bootfile, PISM.PISM_NOWRITE)
  pio.inq_grid(variable, grid, periodicity)
  pio.close()

  grid.compute_nprocs();
  grid.compute_ownership_ranges();
  grid.allocate()

class Bunch:
  def __init__(self, **kwds):
      self.__dict__.update(kwds)

  def has_key(self,k):
    return self.__dict__.has_key(k)

  def __getitem__(self,k):
    return self.__dict__.get(k)

  def update(self,**kwds):
    self.__dict__.update(**kwds)

  def __repr__(self):
      keys = self.__dict__.keys()
      return 'Bunch(%s)'%', '.join(['%s=%s'%(k,self.__dict__[k]) for k in keys])

def randVectorS(grid,scale,stencil_width=None):
  rv = PISM.IceModelVec2S();
  if stencil_width is None:
    rv.create(grid, 'rand vec', PISM.kNoGhosts)
  else:
    rv.create(grid, 'rand vec', PISM.kHasGhosts, stencil_width)
  shape=(grid.xm,grid.ym)
  r = np.random.normal(scale=scale,size=shape)
  with PISM.util.Access(nocomm=rv):
    for (i,j) in grid.points():
      rv[i,j] = r[i-grid.xs,j-grid.ys]
  if stencil_width is not None:
    rv.update_ghosts();
  return rv

def randVectorV(grid,scale,stencil_width=None):
  rv = PISM.IceModelVec2V();
  if stencil_width is None:
    rv.create(grid, 'rand vec', PISM.kNoGhosts)
  else:
    rv.create(grid, 'rand vec', PISM.kHasGhosts,stencil_width)

  shape=(grid.xm,grid.ym)
  r_u = np.random.normal(scale=scale,size=shape)
  r_v = np.random.normal(scale=scale,size=shape)
  with PISM.util.Access(nocomm=rv):
    for (i,j) in grid.points():
      rv[i,j].u = r_u[i-grid.xs,j-grid.ys]
      rv[i,j].v = r_v[i-grid.xs,j-grid.ys]
    if stencil_width is not None:
      rv.update_ghosts();
  return rv

