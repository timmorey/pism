# Copyright (C) 2011, 2012 David Maxwell
# 
# This file is part of PISM.
# 
# PISM is free software; you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# 
# PISM is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
# 
# You should have received a copy of the GNU General Public License
# along with PISM; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

import PISM, math
from PISM import util, netCDF, model
from petsc4py import PETSc

SSAAlgorithms = {"fem":PISM.SSAFEM, "fd":PISM.SSAFD }

class SSARun:
  def __init__(self):
    self.grid = None
    self.config = None
    self.modeldata = None
  
  def setup(self):
    self._setFromOptions()
    
    self._initGrid()
    if self.grid == None:
      raise RuntimeError("SSARun failed to provide a grid.")

    self.modeldata = self._constructModelData()
    if self.modeldata == None:
      raise RuntimeError("SSARun._constructModelData failed to provide a ModelData.")
    self.config = self.modeldata.config

    self._initPhysics()
    if (self.modeldata.basal == None) or (self.modeldata.enthalpyconverter == None):
      raise RuntimeError("SSARun._initPhysics failed to initialize the physics of the underlying SSA solver.")

    self.ssa = self._constructSSA()
    if self.ssa == None:
      raise RuntimeError("SSARun._constructSSA failed to provide an SSA.")

    self._initSSACoefficients()
    # FIXME: is there a reasonable check to do here?

    self._initSSA()

  def teardown(self):
    pass

  #//! Solve the SSA
  def solve(self):
    vecs = self.modeldata.vecs;

    pvars = vecs.asPISMVars()
    self.ssa.init(pvars)
    if vecs.has('vel_bc'):
      self.ssa.set_boundary_conditions(vecs.bc_mask,vecs.vel_bc)


    PISM.verbPrintf(2,self.grid.com,"* Solving the SSA stress balance ...\n");
    fast = False;
    self.ssa.update(fast);
    vecs.add(self.ssa.get_2D_advective_velocity())

  def write(self,filename):
    grid = self.grid
    vecs = self.modeldata.vecs

    pio = PISM.PIO(grid.com, grid.rank, "netcdf3")
    pio.open(filename, PISM.NC_WRITE)
    pio.def_time(grid.config.get_string("time_dimension_name"),
                 grid.config.get_string("calendar"), grid.time.units())
    pio.append_time(grid.config.get_string("time_dimension_name"),0.0)
    pio.close()

    # Save time & command line
    PISM.util.writeProvenance(filename)

    vecs.writeall(filename)
  
    if vecs.has('vel_ssa'):
      cbar = util.standardCBar(self.grid);
      vecs.vel_ssa.magnitude(cbar)
      cbar.mask_by(vecs.thickness,-0.01/PISM.secpera);
      cbar.write(filename)

  def _setFromOptions(self):
    pass

  def _constructModelData(self):
    return model.ModelData(self.grid)

  def _initGrid(self):
    raise NotImplementedError()
    
  def _initPhysics(self):
    raise NotImplementedError()

  def _allocStdSSACoefficients(self):
    vecs = self.modeldata.vecs; grid = self.grid
    vecs.add( util.standardIceSurfaceVec( grid ), 'surface')
    vecs.add( util.standardIceThicknessVec( grid ), 'thickness')
    vecs.add( util.standardBedrockElevationVec(grid), 'bed')
    vecs.add( util.standardYieldStressVec( grid ), 'tauc')
    vecs.add( util.standardEnthalpyVec( grid ), 'enthalpy' )
    vecs.add( util.standardIceMask( grid ), 'ice_mask' )

  def _allocateBCs(self,velname='_bc',maskname='bc_mask'):
    vecs = self.modeldata.vecs
    vecs.add( util.standard2dVelocityVec( self.grid, name=velname, desc='SSA velocity boundary condition',intent='intent' ), "vel_bc" )
    vecs.add( util.standardBCMask( self.grid,name=maskname ), "bc_mask" )

  def _initSSACoefficients(self):
    raise NotImplementedError()

  def _constructSSA(self):
    md = self.modeldata
    return SSAAlgorithms[md.config.get_string("ssa_method")](md.grid,md.basal,md.enthalpyconverter,md.config)

  def _initSSA(self):
    pass

class SSAExactTestCase(SSARun):
  def __init__(self,Mx,My):
    SSARun.__init__(self)
    self.Mx = Mx; self.My = My;

    # For convenience, provide a grid. It will get initialized later
    # on when _initGrid is called by our setup method.
    self.grid = PISM.Context().newgrid()
  
  def run(self,output_file):
    self.setup()
    self.solve()
    self.report()
    self.write(output_file)
    self.teardown()
  
  def report(self):
      grid = self.grid

      ssa_stdout = self.ssa.stdout_report()
      PISM.verbPrintf(3,grid.com,ssa_stdout)

      maxvecerr = 0.0; avvecerr = 0.0; 
      avuerr = 0.0; avverr = 0.0;
      maxuerr = 0.0; maxverr = 0.0;

      if (self.config.get_flag("do_pseudo_plastic_till") and
          self.config.get("pseudo_plastic_q") != 1.0):
        PISM.verbPrintf(1,grid.com, "WARNING: numerical errors not valid for pseudo-plastic till\n")
      PISM.verbPrintf(1,grid.com, "NUMERICAL ERRORS in velocity relative to exact solution:\n")

      vel_ssa = self.modeldata.vecs.vel_ssa

      vel_ssa.begin_access()

      exactvelmax = 0; gexactvelmax = 0;
      for (i,j) in self.grid.points():
        x=grid.x[i]; y=grid.y[j]
        (uexact,vexact) = self.exactSolution(i,j,x,y);
        exactnormsq=math.sqrt(uexact*uexact+vexact*vexact);
        exactvelmax = max(exactnormsq,exactvelmax);
        solution = vel_ssa[i,j]
        uerr = abs(solution.u-uexact)
        verr = abs(solution.v-vexact)
        avuerr += uerr;
        avverr += verr;
        maxuerr = max(maxuerr,uerr);
        maxverr = max(maxverr,verr)
        vecerr = math.sqrt(uerr * uerr + verr * verr);
        maxvecerr = max(maxvecerr,vecerr);
        avvecerr = avvecerr + vecerr;

      vel_ssa.end_access();
      
      gexactvelmax = PISM.globalMax(exactvelmax,grid.com);      
      gmaxuerr     = PISM.globalMax(maxuerr,grid.com);
      gmaxverr     = PISM.globalMax(maxverr,grid.com);
      gavuerr      = PISM.globalSum(avuerr,grid.com) / (grid.Mx*grid.My)
      gavverr      = PISM.globalSum(avverr,grid.com) / (grid.Mx*grid.My)
      gmaxvecerr   = PISM.globalMax(maxvecerr,grid.com)
      gavvecerr    = PISM.globalSum(avvecerr,grid.com) / (grid.Mx*grid.My)

      report_velocity_scale = PISM.secpera
      PISM.verbPrintf(1,grid.com, "velocity  :  maxvector   prcntavvec      maxu      maxv       avu       avv\n");
      #FIXME: variable arguments to verbPrintf are not working.  For now, do the string formatting on the python side.  Maybe
      #this is the best approach.
      PISM.verbPrintf(1,grid.com, "           %11.4f%13.5f%10.4f%10.4f%10.4f%10.4f\n",
                      gmaxvecerr*report_velocity_scale, (gavvecerr/gexactvelmax)*100.0,
                      gmaxuerr*report_velocity_scale, gmaxverr*report_velocity_scale, gavuerr*report_velocity_scale, 
                      gavverr*report_velocity_scale) 
      PISM.verbPrintf(1,grid.com, "NUM ERRORS DONE\n")


  def exactSolution(self,i,j,xi,xj):
    raise NotImplementedError()

  def write(self,filename):
    SSARun.write(self,filename)
    
    grid=self.grid
    exact = util.standard2dVelocityVec(grid,name="_exact",desc="SSA exact solution",intent="diagnostic")
    exact.begin_access()
    for (i,j) in grid.points():
      exact[i,j] = self.exactSolution(i,j,grid.x[i],grid.y[j])
    exact.end_access();
    exact.write(filename);

class SSAFromInputFile(SSARun):
  def __init__(self,boot_file):
    SSARun.__init__(self)
    self.grid = PISM.Context().newgrid()
    self.config = self.grid.config
    self.boot_file = boot_file
    self.phi_to_tauc = False
    self.is_regional = False

  def _setFromOptions(self):
    for o in PISM.OptionsGroup(self.grid.com,"","SSAFromInputFile"):
      self.phi_to_tauc = PISM.optionsIsSet("-phi_to_tauc","Recompute pseudo yield stresses from till friction angles.")
      self.is_regional = PISM.optionsIsSet("-regional")

  def _initGrid(self):
    # FIXME: allow specification of Mx and My different from what's
    # in the boot_file.
    periodicity = PISM.XY_PERIODIC
    (pstring,pflag) = PISM.optionsListWasSet(self.grid.com,'-periodicity',"Grid periodicity",['x','y','xy', 'none'],'xy')
    if pflag:
      pdict = {'x':PISM.X_PERIODIC,   'y':PISM.Y_PERIODIC, 
               'xy':PISM.XY_PERIODIC, 'none':PISM.NOT_PERIODIC }
      periodicity = pdict[pstring]
    else:
      if self.is_regional and (self.config.get_string("ssa_method")=="fem"):
        periodicity=PISM.NOT_PERIODIC

    PISM.util.init_grid_from_file(self.grid,self.boot_file,periodicity);

  def _initPhysics(self):
    config = self.config

    if config.get_flag("do_pseudo_plastic_till"):
      basal = PISM.IceBasalResistancePseudoPlasticLaw(config);
    else:
      basal = PISM.IceBasalResistancePlasticLaw(config);

    enthalpyconverter = PISM.EnthalpyConverter(config)
    if PISM.getVerbosityLevel() >3:
      enthalpyconverter.viewConstants(PETSc.Viewer.STDOUT())

    if PISM.optionsIsSet("-ssa_glen"):
      config.set_string("ssa_flow_law", "isothermal_glen")
      config.scalar_from_option("ice_softness", "ice_softness")
    else:
      config.set_string("ssa_flow_law", "gpbld")

    self.modeldata.setPhysics(basal,enthalpyconverter)

  def _initSSACoefficients(self):
    # Build the standard thickness, bed, etc
    self._allocStdSSACoefficients()

    vecs = self.modeldata.vecs
    thickness = vecs.thickness; bed = vecs.bed; enthalpy = vecs.enthalpy
    mask = vecs.ice_mask; surface = vecs.surface

    # Read in the PISM state variables that are used directly in the SSA solver
    for v in [thickness, bed, enthalpy]:
      v.regrid(self.boot_file,True)

    # variables mask and surface are computed from the geometry previously read
    sea_level = 0 # FIXME setFromOption?
    gc = PISM.GeometryCalculator(sea_level, self.config)
    gc.compute(bed,thickness,mask,surface)

    if util.fileHasVariable(self.boot_file,'ssa_driving_stress_x'):
      vecs.add( util.standardDrivingStressX(self.grid))
      vecs.ssa_driving_stress_x.regrid(self.boot_file,critical=True)

    if util.fileHasVariable(self.boot_file,'ssa_driving_stress_y'):
      vecs.add( util.standardDrivingStressY(self.grid))
      vecs.ssa_driving_stress_y.regrid(self.boot_file,critical=True)

    # For a regional run we'll need no_model_mask, usurfstore, thkstore
    if self.is_regional:
      vecs.add( util.standardNoModelMask(self.grid), 'no_model_mask' )
      vecs.no_model_mask.regrid(self.boot_file,True)
      
      if util.fileHasVariable(self.boot_file,'usurfstore'):
        vecs.add( util.standardIceSurfaceStoreVec(self.grid) )
        vecs.usurfstore.regrid(self.boot_file,True)
      else:        
        vecs.add( vecs.surface, 'usurfstore')
        vecs.setPISMVarsName('usurfstore','usurfstore')

      if util.fileHasVariable(self.boot_file,'thkstore'):
        vecs.add( util.standardIceThicknessStoreVec(self.grid) )
        vecs.thkstore.regrid(self.boot_file,True)
      else:        
        vecs.add( vecs.thickness, 'thkstore')
        vecs.setPISMVarsName('thkstore','thkstore')


    # Compute yield stress from PISM state variables
    # (basal melt rate, tillphi, and basal water height)
    grid = self.grid

    if self.phi_to_tauc:
      bmr   = PISM.util.standardBasalMeltRateVec(grid)
      tillphi = PISM.util.standardTillPhiVec(grid)
      bwat = PISM.util.standardBasalWaterVec(grid)
      for v in [bmr,tillphi,bwat]:
         v.regrid(self.boot_file,True)
         vecs.add(v)
      
      if self.is_regional:
        yieldstress = PISM.PISMRegionalDefaultYieldStress(self.modeldata.grid,self.modeldata.config)
      else:
        yieldstress = PISM.PISMMohrCoulombYieldStress(self.modeldata.grid,self.modeldata.config)
      yieldstress.init(vecs.asPISMVars())
      yieldstress.basal_material_yield_stress(vecs.tauc)
    else:
      vecs.tauc.regrid(self.boot_file,True)

    if self.config.get_flag('ssa_dirichlet_bc'):
      vecs.add( util.standard2dVelocityVec( self.grid, name='_ssa_bc', desc='SSA velocity boundary condition',intent='intent' ), "vel_ssa_bc" )
      has_u_ssa_bc = util.fileHasVariable(self.boot_file,'u_ssa_bc');
      has_v_ssa_bc = util.fileHasVariable(self.boot_file,'v_ssa_bc');
      if (not has_u_ssa_bc) or (not has_v_ssa_bc):
        PISM.verbPrintf(2,grid.com, "Input file '%s' missing Dirichlet boundary data u/v_ssa_bc; using zero default instead." % self.boot_file)
        vecs.vel_ssa_bc.set(0.)
      else:
        vecs.vel_ssa_bc.regrid(self.boot_file,True)

      if self.is_regional:
        vecs.add( vecs.no_model_mask, 'bc_mask')
      else:
        vecs.add( util.standardBCMask( self.grid ), 'bc_mask' )
        bc_mask_name = vecs.bc_mask.string_attr("name")
        if util.fileHasVariable(self.boot_file,bc_mask_name):
          vecs.bc_mask.regrid(self.boot_file,True)          
        else:
          PISM.verbPrintf(2,grid.com,"Input file '%s' missing Dirichlet location mask '%s'.  Default to no Dirichlet locations." %(self.boot_file,bc_mask_name))
          vecs.bc_mask.set(0)
      vecs.setPISMVarsName('bc_mask','bcflag')

  def _constructSSA(self):
    md = self.modeldata
    if self.is_regional and (md.config.get_string("ssa_method")=="fd"):
      algorithm = PISM.SSAFD_Regional
    else:
      algorithm = SSAAlgorithms[md.config.get_string("ssa_method")]
    return algorithm(md.grid, md.basal, md.enthalpyconverter, md.config)
